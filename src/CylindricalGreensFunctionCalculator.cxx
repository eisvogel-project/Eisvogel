#include "Eisvogel/CylindricalGreensFunctionCalculator.hh"
#include "Vector.hh"
#include "NDVecArray.hh"
#include "Symmetry.hh"
#include <unordered_map>

CylindricalGreensFunctionCalculator::CylindricalGreensFunctionCalculator(CylinderGeometry& geom, const Antenna& antenna, scalar_t t_end,
									 double courant_factor, double resolution, double pml_width) : m_t_end(0) {
  
  m_start_coords = std::make_shared<RZTCoordVector>((scalar_t)0.0, geom.GetZMin(), (scalar_t)0.0);
  m_end_coords = std::make_shared<RZTCoordVector>(geom.GetRMax(), geom.GetZMax(), t_end);
  
  m_gv = std::make_shared<meep::grid_volume>(meep::volcyl(geom.GetRMax(), geom.GetZMax() - geom.GetZMin(), resolution));
  m_s = std::make_shared<meep::structure>(*m_gv, geom, meep::pml(pml_width), meep::identity(), 0, courant_factor);
  m_f = std::make_shared<meep::fields>(m_s.get());

  antenna.AddToGeometry(*m_f, geom);

  std::cout << "Constructed geom with start = " << *m_start_coords << " and end = " << *m_end_coords << std::endl;
}

template <typename RegionKeyT, std::size_t dims>
class FieldStatisticsTracker {

public:

  using region_t = NDVecArray<scalar_t, dims, 1>;
  using shape_t = typename region_t::shape_t;
  using ind_t = typename region_t::ind_t;
  
public:

  FieldStatisticsTracker(std::size_t subsampling) : m_subsampling(subsampling) {  }

  void AddRegion(const RegionKeyT& region_key, const shape_t& region_shape, scalar_t init_value = 0.0) {
    shape_t subsampled_shape = to_subsampled_shape(region_shape);
    m_max_data.emplace(std::make_pair(region_key, region_t(subsampled_shape, init_value)));

    std::cout << "for chunk with key = " << region_key << std::endl;
    std::cout << "constructed max tracker with shape = " << subsampled_shape << std::endl;
    std::cout << "for original chunk with shape = " << region_shape << std::endl;
  }

  void UpdateStatisticsForRegion(const RegionKeyT& region_key, const region_t& region_data) {

  }

  scalar_t GetMaxLocal(const RegionKeyT& region_key, const ind_t& ind) {
    assert(m_max_data.contains(region_key));
    ind_t subsampled_ind = to_subsampled_ind(ind);
    return m_max_data.at(region_key)[subsampled_ind];
  }

private:

  shape_t to_subsampled_shape(const shape_t& shape) {
    return (shape + m_subsampling - 1) / m_subsampling;
  }

  ind_t to_subsampled_ind(const ind_t& ind) {
    return ind / m_subsampling;
  }
  
private:

  std::size_t m_subsampling;
  std::unordered_map<RegionKeyT, region_t> m_max_data;

};

// Local utilities
namespace {

  std::filesystem::path get_tmp_dir(std::filesystem::path parent_dir) {
    char tmpdir_template[] = "eisvogel.XXXXXX";
    return parent_dir / std::filesystem::path(mkdtemp(tmpdir_template));
  }
}

// Data container to pass into the MEEP callbacks defined below. Contains all the relevant information that needs to be passed
// back and forth between MEEP and Eisvogel.
struct ChunkloopData {

};

// Callbacks to interface with MEEP
namespace meep {

  // This is called once at the very beginning of the simulation run. It probes the chunk arrangement generated by meep
  // and sets up various things for later.
  void eisvogel_setup_chunkloop(fields_chunk* fc, int ichunk, component cgrid, ivec is, ivec ie,
				vec s0, vec s1, vec e0, vec e1, double dV0, double dV1,
				ivec shift, std::complex<double> shift_phase,
				const symmetry& S, int sn, void* cld) {

    
    
  }

  // This is called for every simulation timestep and performs the saving of the Green's function.
  void eisvogel_saving_chunkloop(fields_chunk* fc, int ichunk, component cgrid, ivec is, ivec ie,
				 vec s0, vec s1, vec e0, vec e1, double dV0, double dV1,
				 ivec shift, std::complex<double> shift_phase,
				 const symmetry& S, int sn, void* cld) {
    
    
  }  
} // end namespace meep

void CylindricalGreensFunctionCalculator::Calculate(std::filesystem::path outdir, std::filesystem::path local_scratchdir, std::filesystem::path global_scratchdir) {

  int job_mpi_rank = meep::my_rank();

  // Working directory in process-local scratch area
  std::filesystem::path local_workdir = get_tmp_dir(local_scratchdir);

  // Working directory in global scratch area
  std::filesystem::path global_workdir;
  if(meep::am_master()) {
    global_workdir = get_tmp_dir(global_scratchdir);
  }

  // Output directory
  if(meep::am_master()) {
    if(std::filesystem::exists(outdir)) {
      throw std::runtime_error("Error: cowardly refusing to overwrite an already-existing Green's function!");
    }
    std::filesystem::create_directory(outdir);
  }

  meep::all_wait();

  // Some typedefs
  constexpr std::size_t vec_dims = 2;     // we only need to store E_r and E_z
  constexpr std::size_t dims = SpatialSymmetry::Cylindrical<scalar_t, vec_dims>::dims;
  using chunk_t = typename SpatialSymmetry::Cylindrical<scalar_t, vec_dims>::chunk_t;
  using darr_t = typename SpatialSymmetry::Cylindrical<scalar_t, vec_dims>::darr_t;

  // Number of time slices before a new chunk is started
  std::size_t requested_chunk_size_t = 400;

  // ================================================================
  // First stage: each MPI process calculates and stores its part
  //              of the Green's function in `local_workdir`
  // ================================================================
  
  std::size_t cache_depth = 1;   // all chunks are created one time-slice at a time, no need for a large cache
  TZRVector<std::size_t> init_cache_el_shape(1);
  TZRVector<std::size_t> streamer_chunk_shape(stor::INFTY); streamer_chunk_shape[0] = 1; // serialize one time slice at a time
  darr_t darr(local_workdir, cache_depth, init_cache_el_shape, streamer_chunk_shape);

  // Set up tracker to follow field statistics such as the maximum field strength
  std::size_t fstats_subsampling = 2;  
  FieldStatisticsTracker<int, dims> bla(fstats_subsampling);

  scalar_t dynamic_range = 50;     // max. dynamic range of field strength to keep in the stored output
  scalar_t abs_min_field = 1e-20;  // absolute minimum of field to retain in the stored output
  
  // std::cout << bla.GetMaxLocal(1, {1u, 1u}) << std::endl;
  
}

