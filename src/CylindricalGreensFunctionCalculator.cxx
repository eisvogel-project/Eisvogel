#include "Eisvogel/CylindricalGreensFunctionCalculator.hh"
#include "Vector.hh"
#include "NDVecArray.hh"
#include "Symmetry.hh"
#include "GreensFunction.hh"
#include <unordered_map>

CylindricalGreensFunctionCalculator::CylindricalGreensFunctionCalculator(CylinderGeometry& geom, const Antenna& antenna, scalar_t t_end) :
  m_t_end(0), m_geom(geom), m_antenna(antenna) {
  
  m_start_coords = std::make_shared<RZTCoordVector>((scalar_t)0.0, geom.GetZMin(), (scalar_t)0.0);
  m_end_coords = std::make_shared<RZTCoordVector>(geom.GetRMax(), geom.GetZMax(), t_end);
  
  std::cout << "Constructed geom with start = " << *m_start_coords << " and end = " << *m_end_coords << std::endl;
}

template <typename RegionKeyT, std::size_t dims>
class FieldStatisticsTracker {

public:

  using region_t = NDVecArray<scalar_t, dims, 1>;
  using shape_t = typename region_t::shape_t;
  using ind_t = typename region_t::ind_t;
  
public:

  FieldStatisticsTracker(std::size_t subsampling) : m_subsampling(subsampling) {  }

  void AddRegion(const RegionKeyT& region_key, const shape_t& region_shape, scalar_t init_value = 0.0) {
    shape_t subsampled_shape = to_subsampled_shape(region_shape);
    m_max_data.emplace(std::make_pair(region_key, region_t(subsampled_shape, init_value)));

    std::cout << "for chunk with key = " << region_key << std::endl;
    std::cout << "constructed max tracker with shape = " << subsampled_shape << std::endl;
    std::cout << "for original chunk with shape = " << region_shape << std::endl;
  }

  void UpdateStatisticsForRegion(const RegionKeyT& region_key, const region_t& region_data) {

  }

  scalar_t GetMaxLocal(const RegionKeyT& region_key, const ind_t& ind) {
    assert(m_max_data.contains(region_key));
    ind_t subsampled_ind = to_subsampled_ind(ind);
    return m_max_data.at(region_key)[subsampled_ind];
  }

private:

  shape_t to_subsampled_shape(const shape_t& shape) {
    return (shape + m_subsampling - 1) / m_subsampling;
  }

  ind_t to_subsampled_ind(const ind_t& ind) {
    return ind / m_subsampling;
  }
  
private:

  std::size_t m_subsampling;
  std::unordered_map<RegionKeyT, region_t> m_max_data;

};

// Local utilities
namespace {

  std::filesystem::path create_tmp_dir_in(std::filesystem::path parent_dir) {
    if(!std::filesystem::exists(parent_dir)) {
      std::filesystem::create_directory(parent_dir);
    }
    std::string tmpdir_template = parent_dir / "eisvogel.XXXXXX";    
    mkdtemp(tmpdir_template.data());
    return tmpdir_template;
  }
}

// Data container to keep track of metadata information pertaining to a single spatial simulation chunk.
template <typename SpatialSymmetryT>
struct SimulationChunkMetadata {

  using shape_t = Vector<std::size_t, SpatialSymmetryT::dims - 1>;

  SimulationChunkMetadata(const shape_t& chunk_shape) : chunk_shape(chunk_shape) { }
  
  shape_t chunk_shape;  
};

// Data container to pass into the MEEP callbacks defined below. Contains all the relevant information that needs to be passed
// back and forth between MEEP and Eisvogel.
template <typename SpatialSymmetryT>
struct ChunkloopData {

  using meep_chunk_ind_t = int;
  using sim_chunk_meta_t = SimulationChunkMetadata<SpatialSymmetryT>;
  using darr_t = typename SpatialSymmetryT::darr_t;
  using chunk_t = typename SpatialSymmetryT::darr_t::chunk_t;
  using view_t = typename chunk_t::view_t;  
  using fstats_t = FieldStatisticsTracker<meep_chunk_ind_t, SpatialSymmetryT::dims - 1>;

  ChunkloopData(std::size_t ind_time, darr_t& fstor, fstats_t& fstats, scalar_t dynamic_range, scalar_t abs_min_field,
		const chunk_t::shape_t& init_field_buffer_shape, const fstats_t::shape_t& init_stat_buffer_shape) :
    ind_time(ind_time), fstor(fstor), fstats(fstats), dynamic_range(dynamic_range), abs_min_field(abs_min_field),
    field_buffer(init_field_buffer_shape), field_stat_buffer(init_stat_buffer_shape) { }
  
  std::size_t ind_time;  // Time index
  darr_t& fstor;  // Reference to field storage
  fstats_t& fstats;  // Reference to field statistics tracker
  
  scalar_t dynamic_range;  // Dynamic range of field to keep
  scalar_t abs_min_field;  // Abs. minimum field value to keep

  chunk_t field_buffer;  // Buffer to assemble field values
  fstats_t::region_t field_stat_buffer;  // Buffer for field statistic values
  
  std::unordered_map<meep_chunk_ind_t, sim_chunk_meta_t> sim_chunk_meta;  // Metadata for all simulation chunks
};

using CylindricalChunkloopData = ChunkloopData<SpatialSymmetry::Cylindrical<scalar_t>>;

// Callbacks to interface with MEEP
namespace meep {

  // This is called once at the very beginning of the simulation run. It probes the chunk arrangement generated by meep
  // and sets up various things for later.
  void eisvogel_setup_chunkloop(fields_chunk* fc, int ichunk, component cgrid, ivec is, ivec ie,
				vec s0, vec s1, vec e0, vec e1, double dV0, double dV1,
				ivec shift, std::complex<double> shift_phase,
				const symmetry& S, int sn, void* cld) {

    CylindricalChunkloopData* chunkloop_data = static_cast<CylindricalChunkloopData*>(cld);

    // index vectors for start and end of chunk
    ivec isS = S.transform(is, sn) + shift;
    ivec ieS = S.transform(ie, sn) + shift;

    // determine rank (= number of spatial dimensions) of this simulation chunk
    std::size_t rank = number_of_directions(fc -> gv.dim);
    constexpr std::size_t required_rank = 2;
    assert(rank == required_rank);  // For a cylindrical geometry, we expect a 2d spatial simulation volume

    // determine the shape of this simulation chunk
    // shape = {shape_z, shape_r}
    std::size_t shape[required_rank] = {0};
    std::size_t index = 0;
    LOOP_OVER_DIRECTIONS(fc -> gv.dim, d) {
      std::size_t cur_len = std::max(0, (ie.in_direction(d) - is.in_direction(d)) / 2 + 1);
      shape[index++] = cur_len;
    }

    // Build and record the chunk metadata
    ZRVector<std::size_t> chunk_shape{shape[0], shape[1]};
    CylindricalChunkloopData::sim_chunk_meta_t cur_meta(chunk_shape);    
    chunkloop_data -> sim_chunk_meta.emplace(std::make_pair(ichunk, cur_meta));

    // Setup field statistics tracker for this chunk
    chunkloop_data -> fstats.AddRegion(ichunk, chunk_shape);
  }

  // This is called for every simulation timestep and performs the saving of the Green's function.
  void eisvogel_saving_chunkloop(fields_chunk* fc, int ichunk, component cgrid, ivec is, ivec ie,
				 vec s0, vec s1, vec e0, vec e1, double dV0, double dV1,
				 ivec shift, std::complex<double> shift_phase,
				 const symmetry& S, int sn, void* cld) {

    std::cout << "in saving chunkloop" << std::endl;
    
    CylindricalChunkloopData* chunkloop_data = static_cast<CylindricalChunkloopData*>(cld);    
    
    // Number of time slices before a new chunk is started
    std::size_t requested_chunk_size_t = 400;

    // Make sure the buffers are of the correct size for this simulation chunk
    ZRVector<std::size_t> spatial_chunk_shape(chunkloop_data -> sim_chunk_meta.at(ichunk).chunk_shape);
    TZRVector<std::size_t> field_slice_shape(1, spatial_chunk_shape);

    chunkloop_data -> field_stat_buffer.resize(spatial_chunk_shape);
    chunkloop_data -> field_buffer.resize(field_slice_shape);

    assert(is.z() >= 0);
    assert(is.r() >= 0);

    // Start index of this simulation chunk
    ZRIndexVector spatial_chunk_start_ind{
      (std::size_t)((is.z() - 1) / 2),
      (std::size_t)((is.r() - 1) / 2)
    };    
    TZRIndexVector chunk_start_ind(chunkloop_data -> ind_time, spatial_chunk_start_ind);
      
    // some preliminary setup
    vec rshift(shift * (0.5*fc->gv.inva));  // shift into unit cell for PBC geometries
    
    // prepare the list of field components to fetch at each grid point
    component components[] = {Ez, Er};
    chunkloop_field_components data(fc, cgrid, shift_phase, S, sn, 2, components);

    // loop over all grid points in chunk
    LOOP_OVER_IVECS(fc->gv, is, ie, idx) {

      // get grid indices and coordinates of parent point
      IVEC_LOOP_ILOC(fc->gv, iparent);  // grid indices
      IVEC_LOOP_LOC(fc->gv, rparent);   // cartesian coordinates
      
      // apply symmetry transform to get grid indices and coordinates of child point
      ivec ichild = S.transform(iparent, sn) + shift;
      vec rchild = S.transform(rparent, sn) + rshift;	    

      // Index of current simulation point
      ZRIndexVector cur_spatial_ind{
	(std::size_t)((ichild.z() - 1) / 2),
	(std::size_t)((ichild.r() - 1) / 2)
      };
      TZRIndexVector cur_ind(chunkloop_data -> ind_time, cur_spatial_ind);
      
      // fetch field components at child point ...
      data.update_values(idx);
      double E_z_val = data.values[0].real();
      double E_r_val = data.values[1].real();      
      double E_abs_val = std::sqrt(E_z_val * E_z_val + E_r_val * E_r_val);

      // ... and store them
      CylindricalChunkloopData::view_t field_elem = chunkloop_data -> field_buffer[cur_ind - chunk_start_ind];
      field_elem[0] = E_r_val;
      field_elem[1] = E_z_val;
      chunkloop_data -> field_stat_buffer[cur_spatial_ind - spatial_chunk_start_ind] = E_abs_val;      
    }

    // Update statistics tracker
    chunkloop_data -> fstats.UpdateStatisticsForRegion(ichunk, chunkloop_data -> field_stat_buffer);

    // -------------
    // TODO: put truncation of small field values here
    // -------------

    if(chunkloop_data -> ind_time % requested_chunk_size_t == 0) {

      // Register this slice as the beginning of a new chunk ...
      chunkloop_data -> fstor.RegisterChunk(chunkloop_data -> field_buffer, chunk_start_ind);
    }
    else {
      // ... or append it to an already-existing chunk along the outermost (time) direction
      chunkloop_data -> fstor.AppendSlice<0>(chunk_start_ind, chunkloop_data -> field_buffer);
    }
  }  
} // end namespace meep

void CylindricalGreensFunctionCalculator::calculate_mpi_chunk(std::filesystem::path outdir, std::filesystem::path local_scratchdir,
							      double courant_factor, double resolution, double pml_width) {
  
  std::shared_ptr<meep::grid_volume> meep_gv = std::make_shared<meep::grid_volume>(meep::volcyl(m_geom.GetRMax(), m_geom.GetZMax() - m_geom.GetZMin(), resolution));
  std::shared_ptr<meep::structure> meep_s = std::make_shared<meep::structure>(*meep_gv, m_geom, meep::pml(pml_width), meep::identity(), 0, courant_factor);
  std::shared_ptr<meep::fields> meep_f = std::make_shared<meep::fields>(meep_s.get());

  m_antenna.AddToGeometry(*meep_f, m_geom);
  
  // Some typedefs
  constexpr std::size_t dims = SpatialSymmetry::Cylindrical<scalar_t>::dims;
  // using chunk_t = typename SpatialSymmetry::Cylindrical<scalar_t>::chunk_t;
  using darr_t = typename SpatialSymmetry::Cylindrical<scalar_t>::darr_t;
  
  // Working directory in process-local scratch area
  std::filesystem::path local_workdir = create_tmp_dir_in(local_scratchdir);  
  
  std::size_t cache_depth = 1;   // all chunks are created one time-slice at a time, no need for a large cache
  TZRVector<std::size_t> init_cache_el_shape(1);
  TZRVector<std::size_t> streamer_chunk_shape(stor::INFTY); streamer_chunk_shape[0] = 1; // serialize one time slice at a time
  darr_t darr(local_workdir, cache_depth, init_cache_el_shape, streamer_chunk_shape);

  // Set up tracker to follow field statistics such as the maximum field strength
  // This corresponds to a constant-time slice, which has one fewer dimensions
  std::size_t fstats_subsampling = 2;  
  FieldStatisticsTracker<meep_chunk_ind_t, dims - 1> fstats(fstats_subsampling);

  scalar_t dynamic_range = 50;     // max. dynamic range of field strength to keep in the stored output
  scalar_t abs_min_field = 1e-20;  // absolute minimum of field to retain in the stored output

  // Prepare data container to pass to all MEEP callbacks
  TZRVector<std::size_t> init_field_buffer_shape(1);
  ZRVector<std::size_t> init_field_stat_buffer_shape(1);
  CylindricalChunkloopData cld(0, darr, fstats, dynamic_range, abs_min_field, init_field_buffer_shape, init_field_stat_buffer_shape);

  // Setup simulation run 
  meep_f -> loop_in_chunks(meep::eisvogel_setup_chunkloop, static_cast<void*>(&cld), meep_f -> total_volume());

  // Main simulation loop
  std::size_t stepcnt = 0;
  for(double cur_t = 0.0; cur_t <= m_t_end; cur_t += 0.1) {

    // Time-step the fields
    while (meep_f -> time() < cur_t) {
      meep_f -> step();
    }

    if(meep::am_master()) {
      std::cout << "Simulation time: " << meep_f -> time() << std::endl;
    }

    // Store the Green's function at the present timestep
    cld.ind_time = stepcnt++;
    meep_f -> loop_in_chunks(meep::eisvogel_saving_chunkloop, static_cast<void*>(&cld), meep_f -> total_volume());
  }

  // Swap axes 0 and 2 to go from TZR to RZT
  darr.SwapAxes<0, 2>();
  
  // Move Green's function to the requested output location
  darr.Move(outdir);  
}

void CylindricalGreensFunctionCalculator::merge_mpi_chunks(std::filesystem::path outdir, const std::vector<std::filesystem::path>& indirs) {

  using darr_t = typename SpatialSymmetry::Cylindrical<scalar_t>::darr_t;

  std::size_t cache_depth = 1;
  TZRVector<std::size_t> init_cache_el_shape(1);
  TZRVector<std::size_t> streamer_chunk_shape(stor::INFTY); streamer_chunk_shape[0] = 1; // serialize one time slice at a time
  darr_t darr(outdir, cache_depth, init_cache_el_shape, streamer_chunk_shape); // no big cache needed here, this is just for merging

  for(const std::filesystem::path& indir : indirs) {
    darr.Import(indir);
    std::filesystem::remove_all(indir);
  }
}

void CylindricalGreensFunctionCalculator::rechunk_mpi(std::filesystem::path outdir, std::filesystem::path indir, std::filesystem::path global_scratch_dir,
						      int cur_mpi_id, int number_mpi_jobs, const RZTVector<std::size_t>& requested_chunk_size) {
  
}

void CylindricalGreensFunctionCalculator::Calculate(std::filesystem::path outdir, std::filesystem::path local_scratchdir, std::filesystem::path global_scratchdir,
						    double courant_factor, double resolution, double pml_width) {

  int number_mpi_jobs = meep::count_processors();
  int job_mpi_rank = meep::my_rank();

  // Prepare an empty working directory in global scratch area
  std::filesystem::path global_workdir = global_scratchdir / "eisvogel";
  if(meep::am_master()) {
    if(std::filesystem::exists(global_workdir)) {
      std::filesystem::remove_all(global_workdir);
    }
    std::filesystem::create_directory(global_workdir);
  }

  // Output directory
  if(meep::am_master()) {
    if(std::filesystem::exists(outdir)) {
      throw std::runtime_error("Error: cowardly refusing to overwrite an already-existing Green's function!");
    }
    std::filesystem::create_directory(outdir);
  }

  std::cout << "using global_workdir = " << global_workdir << std::endl;
  
  meep::all_wait();

  auto calc_job_dir = [](int job_mpi_rank) -> std::filesystem::path {
    return std::format("calc_job_{}", job_mpi_rank);
  };
  
  // First stage: each MPI process calculates and stores its part of the Green's function in `job_outdir`
  std::filesystem::path job_outdir = global_scratchdir / calc_job_dir(job_mpi_rank);
  calculate_mpi_chunk(job_outdir, local_scratchdir, courant_factor, resolution, pml_width);

  meep::all_wait();   // Wait for all processes to have finished providing their output
  
  // Second stage: create a new distributed array and import all the chunks. This is now a complete Green's function!
  std::filesystem::path mergedir = global_scratchdir / "merge";      
  if(meep::am_master()) {

    // Assemble output directories from all jobs
    std::vector<std::filesystem::path> to_merge;    
    for(int job_id = 0; job_id < number_mpi_jobs; job_id++) {
      std::filesystem::path cur_job_outdir = global_scratchdir / calc_job_dir(job_id);
      to_merge.push_back(cur_job_outdir);
    }

    // Call the merger
    merge_mpi_chunks(mergedir, to_merge);
  }

  meep::all_wait();
  
  // Third stage: rechunk the complete array and introduce overlap between neighbouring chunks, if requested
  RZTVector<std::size_t> requested_chunk_size(400);
  rechunk_mpi(outdir, mergedir, global_scratchdir, job_mpi_rank, number_mpi_jobs, requested_chunk_size);
  
  meep::all_wait();
  
  // Fourth stage: create the actual Green's function object
  using darr_t = typename SpatialSymmetry::Cylindrical<scalar_t>::darr_t;
  darr_t darr(outdir);
  RZTVector<std::size_t> darr_shape = darr.GetShape();
  RZTCoordVector step_size = (*m_end_coords - *m_start_coords) / (darr_shape.template as_type<scalar_t>() - 1);
  CylindricalGreensFunction(*m_start_coords, *m_end_coords, step_size, std::move(darr));
}

